<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Johnny Ji's Blog</title>
  <meta name="description" content="I’ve been using Reflux for the past while now and up until recently, whenever I needed to make an API call, the workflow has been my React component triggeri...">
  <link rel="stylesheet" href="http://localhost:4000/css/main.css">
  <link rel="canonical" href="/flux/2015/08/26/handing-async-actions-in-reflux.html">
  <link rel="alternate" type="application/rss+xml" title="Johnny Ji" href="/feed.xml"" />
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css">
  <link href="https://fonts.googleapis.com/css?family=Lora:400,400i|Open+Sans:600,400" rel="stylesheet">
</head>


  <body class="lite">

    <header class="header header-lite">
  <a class="header-title header-title-lite" href="http://localhost:4000">JOHNNY JI</a>
  <div class="header-social-media">
    <a href="https://www.github.com/johnnyji" target="_blank" class="header-social-media-link github header-lite">
      <i class="fa fa-github header-lite"></i>
    </a>
    <a href="https://www.twitter.com/johnnyisji" target="_blank" class="header-social-media-link twitter header-lite">
      <i class="fa fa-twitter header-lite"></i>
    </a>
    <a href="https://www.linkedin.com/in/johnnyji" target="_blank" class="header-social-media-link linkedin header-lite">
      <i class="fa fa-linkedin header-lite"></i>
    </a>
    <a href="https://www.instagram.com/johnnyisji"" target="_blank" class="header-social-media-link instagram header-lite">
      <i class="fa fa-instagram header-lite"></i>
    </a>
  </div>
</header>
    

    <div class="page-container">
      <div class="single-post">
  <header class="single-post-header">
    <h1 class="single-post-header-title">Handling Async Actions in Reflux.js</h1>
    <p class="single-post-header-date">// Aug 26, 2015</p>
  </header>
  <div class="single-post-content"><p>I’ve been using Reflux for the past while now and up until recently, whenever I needed to make an API call, the workflow has been my React component triggering the action, the action emitting to the store and the store making an AJAX call and storing the result. Simple right?</p>

<p>It turns out that this isn’t the best pratice for a couple of reasons:</p>

<blockquote>
  <ol>
    <li>Stores are simply means of storing data. The dumber they are, the better</li>
    <li>The action of asking for data should be be moved into it's own utility to better seperate concerns</li>
    <li>If the AJAX call doesn't return the response your store expects, you can choose to not even acknowledge it in the store.</li>
  </ol>
</blockquote>
<p><br /></p>

<p>Keeping this in mind, let’s redesign the way we make AJAX calls in Reflux.js!
<br /></p>

<p>Here we have a simple React component that triggers a <code class="highlighter-rouge">PostActions.loadPosts</code> before it mounts.</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">export</span> <span class="k">default</span> <span class="kr">class</span> <span class="nx">PostsList</span> <span class="kr">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
  <span class="nx">componentWillMount</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">PostActions</span><span class="p">.</span><span class="nx">loadPosts</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="nx">componentDidMount</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">_unsubscribe</span> <span class="o">=</span> <span class="nx">PostStore</span><span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_updateState</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="nx">componentWillUnmount</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">_unsubscribe</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="nx">_updateState</span><span class="p">(</span><span class="nx">newState</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">(</span>
      <span class="c1">// Updates the state of the component received from the store.</span>
    <span class="p">);</span>
  <span class="p">}</span>
  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>And here’s our actions that handle that <code class="highlighter-rouge">loadPosts</code></p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">PostActions</span> <span class="o">=</span> <span class="nx">Reflux</span><span class="p">.</span><span class="nx">createActions</span><span class="p">({</span>
  <span class="s1">'loadPosts'</span><span class="p">:</span> <span class="p">{</span> <span class="nl">children</span><span class="p">:</span> <span class="p">[</span><span class="s1">'completed'</span><span class="p">,</span> <span class="s1">'failed'</span><span class="p">]</span> <span class="p">},</span>
  <span class="s1">'someSyncAction'</span><span class="err">:</span> <span class="p">{},</span>
  <span class="s1">'youGetThePoint'</span><span class="err">:</span> <span class="p">{}</span>
<span class="p">});</span></code></pre></figure>

<p>So basically what’s happening here is when we make our <code class="highlighter-rouge">createActions</code> an object, we can assign a key to it called <code class="highlighter-rouge">children</code>, this has an array containing either <code class="highlighter-rouge">completed</code>, <code class="highlighter-rouge">failed</code> and also <code class="highlighter-rouge">progressed</code> (but we won’t use <code class="highlighter-rouge">progressed</code> in this example).</p>

<p><code class="highlighter-rouge">completed</code> and <code class="highlighter-rouge">failed</code> are just mirrors of resolving and rejecting a promise in JavaScript. Once our aysnc action completes, we can either trigger <code class="highlighter-rouge">completed</code> or <code class="highlighter-rouge">failed</code> based on the outcome of the action. Here’s how.</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">PostActions</span> <span class="o">=</span> <span class="nx">Reflux</span><span class="p">.</span><span class="nx">createActions</span><span class="p">({</span>
  <span class="s1">'loadPosts'</span><span class="p">:</span> <span class="p">{</span> <span class="nl">children</span><span class="p">:</span> <span class="p">[</span><span class="s1">'completed'</span><span class="p">,</span> <span class="s1">'failed'</span><span class="p">]</span> <span class="p">}</span>
<span class="p">});</span>

<span class="nx">PostActions</span><span class="p">.</span><span class="nx">loadPosts</span><span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// We will call our API for posts and return a promise, and based on the outcome of that promise, we either complete or fail the action.</span>

  <span class="nx">ApiCaller</span><span class="p">.</span><span class="nx">sendAjaxRequest</span><span class="p">({</span>
    <span class="na">url</span><span class="p">:</span> <span class="s1">'/api/posts'</span><span class="p">,</span>
    <span class="na">method</span><span class="p">:</span> <span class="s1">'GET'</span>
  <span class="p">})</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">completed</span><span class="p">)</span>
  <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">failed</span><span class="p">);</span>

  <span class="c1">// Your AJAX calls should be moved into it's own seperate API Util class, which I'll demonstrate later.</span>
<span class="p">});</span></code></pre></figure>

<p>The <code class="highlighter-rouge">completed</code> and <code class="highlighter-rouge">failed</code> actions are then reflected in the store by attaching either suffixes onto the corresponding function’s name in the store.</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">PostStore</span> <span class="o">=</span> <span class="nx">Reflux</span><span class="p">.</span><span class="nx">createStore</span><span class="p">({</span>
  <span class="na">init</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span> <span class="c1">//... };</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">listenToMany</span><span class="p">(</span><span class="nx">PostActions</span><span class="p">);</span>
  <span class="p">},</span>
  <span class="na">onLoadPostsCompleted</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// when PostActions.loadPosts.completed() is called, we hit this function.</span>
    <span class="c1">// ... store the posts in state ... trigger state ...</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">posts</span> <span class="o">=</span> <span class="nx">result</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">posts</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">trigger</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">);</span>
  <span class="p">},</span>
  <span class="na">onLoadPostsFailed</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// when PostActions.loadPosts.failed() is called, we hit this function.</span>
    <span class="c1">// ... trigger some error message ...</span>
  <span class="p">}</span>
<span class="p">});</span></code></pre></figure>

<p><br /></p>

<p>Now that we understand the general workflow, let’s hook up our API Util classes!</p>

<p>We need to create a class that acts as a wrapper for all our API calls. It may be very tempting to just fall back to using jQuery’s <code class="highlighter-rouge">$.ajax</code> (which is awesome, I’m not knocking it one bit), but if that’s all we’re using jQuery for, then there’s no need to include the entire dependency in our project. It’d be much easier to write our own AJAX wrapper, which would look something like this:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">export</span> <span class="k">default</span> <span class="kr">class</span> <span class="nx">ApiCaller</span> <span class="p">{</span>

  <span class="c1">// this method assumes that you are sending/receiving JSON</span>
  <span class="c1">// options: { url: ..., method:..., data:... }</span>
  <span class="kr">static</span> <span class="nx">sendAjaxRequest</span><span class="p">(</span><span class="nx">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">request</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">();</span>
      <span class="nx">request</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="nx">options</span><span class="p">.</span><span class="nx">method</span><span class="p">,</span> <span class="nx">options</span><span class="p">.</span><span class="nx">url</span><span class="p">);</span>
      
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="err">`</span><span class="nx">Sending</span> <span class="nx">$</span><span class="p">{</span><span class="nx">options</span><span class="p">.</span><span class="nx">method</span><span class="p">}</span> <span class="nx">Request</span> <span class="nx">to</span> <span class="nx">$</span><span class="p">{</span><span class="nx">options</span><span class="p">.</span><span class="nx">url</span><span class="p">}</span><span class="err">`</span><span class="p">);</span>
      <span class="nx">options</span><span class="p">.</span><span class="nx">data</span> <span class="p">?</span> <span class="nx">request</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">options</span><span class="p">.</span><span class="nx">data</span><span class="p">))</span> <span class="p">:</span> <span class="nx">request</span><span class="p">.</span><span class="nx">send</span><span class="p">();</span>

      <span class="nx">request</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">{</span>
          <span class="na">status</span><span class="p">:</span> <span class="nx">request</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span>
          <span class="na">data</span><span class="p">:</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">request</span><span class="p">.</span><span class="nx">responseText</span><span class="p">)</span>
        <span class="p">};</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">status</span> <span class="o">&gt;=</span> <span class="mi">200</span> <span class="o">&amp;&amp;</span> <span class="nx">result</span><span class="p">.</span><span class="nx">status</span> <span class="o">&lt;=</span> <span class="mi">299</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'Response: '</span><span class="p">,</span> <span class="nx">result</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
          <span class="nx">resolve</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'Response: '</span><span class="p">,</span> <span class="nx">result</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
          <span class="nx">reject</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">};</span>

      <span class="nx">request</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'Response: '</span><span class="p">,</span> <span class="nx">result</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
        <span class="nx">reject</span><span class="p">({</span> <span class="na">status</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span> <span class="na">data</span><span class="p">:</span> <span class="s1">'Connection error'</span> <span class="p">});</span>
      <span class="p">}</span>
    <span class="p">});</span>
  <span class="p">}</span>

<span class="p">}</span></code></pre></figure>

<p>Now that we have our API Util, let’s hook it up to our actions.</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">PostActions</span> <span class="o">=</span> <span class="nx">Reflux</span><span class="p">.</span><span class="nx">createActions</span><span class="p">({</span>
  <span class="s1">'loadPosts'</span><span class="p">:</span> <span class="p">{</span> <span class="nl">children</span><span class="p">:</span> <span class="p">[</span><span class="s1">'completed'</span><span class="p">,</span> <span class="s1">'failed'</span><span class="p">]</span> <span class="p">}</span>
<span class="p">});</span>

<span class="nx">PostActions</span><span class="p">.</span><span class="nx">loadPosts</span><span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// calling either this.completed or this.failed based on the result of our AJAX call</span>

  <span class="nx">Api</span><span class="p">.</span><span class="nx">sendAjaxRequest</span><span class="p">({</span>
    <span class="na">url</span><span class="p">:</span> <span class="s1">'/api/posts'</span><span class="p">,</span>
    <span class="na">method</span><span class="p">:</span> <span class="s1">'GET'</span>
  <span class="p">})</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">completed</span><span class="p">)</span>
  <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">failed</span><span class="p">);</span>
<span class="p">});</span></code></pre></figure>

<p>And we just handle the outcome in our store with <code class="highlighter-rouge">onLoadPostsCompleted</code> and <code class="highlighter-rouge">onLoadPostsFailed</code> and we should be good!</p>

<p>That’s the basic idea behind the workflow. The component will trigger an action, the action will call an API Util call that makes the API call and returns a promise, the action listens to that promise and calls either <code class="highlighter-rouge">completed</code> or <code class="highlighter-rouge">failed</code> based on the outcome of the promise, the store then has two seperate functions that respond to both the completed and failed events emitted by the action.
<br /><br /></p>

<p><strong>Happy AJAXing!</strong></p>
</div>
</div>

    </div>

  </body>

</html>